[{"R:\\react_app\\myapp\\src\\index.js":"1","R:\\react_app\\myapp\\src\\reportWebVitals.js":"2","R:\\react_app\\myapp\\src\\App.js":"3","R:\\react_app\\myapp\\src\\components\\test.js":"4","R:\\react_app\\myapp\\src\\components\\OrbitControls.js":"5","R:\\react_app\\myapp\\src\\components\\GLTFLoader.js":"6","R:\\react_app\\myapp\\src\\components\\Test.js":"7","R:\\react_app\\myapp\\src\\components\\Navbar.js":"8","R:\\react_app\\myapp\\src\\components\\Canvasrobo.js":"9","R:\\react_app\\myapp\\src\\components\\Footer.js":"10","R:\\react_app\\myapp\\src\\components\\Aboutme.js":"11","R:\\react_app\\myapp\\src\\components\\Work.js":"12","R:\\react_app\\myapp\\src\\components\\SmoothScroll.js":"13"},{"size":835,"mtime":1609177854184,"results":"14","hashOfConfig":"15"},{"size":362,"mtime":499162500000,"results":"16","hashOfConfig":"15"},{"size":822,"mtime":1609266822937,"results":"17","hashOfConfig":"15"},{"size":5006,"mtime":1608120084946,"results":"18","hashOfConfig":"15"},{"size":22658,"mtime":1608111973099,"results":"19","hashOfConfig":"15"},{"size":100560,"mtime":1608111973243,"results":"20","hashOfConfig":"15"},{"size":36277,"mtime":1609266467667,"results":"21","hashOfConfig":"15"},{"size":5813,"mtime":1608995554727,"results":"22","hashOfConfig":"15"},{"size":8240,"mtime":1609256997555,"results":"23","hashOfConfig":"15"},{"size":2034,"mtime":1609255631788,"results":"24","hashOfConfig":"15"},{"size":14061,"mtime":1609266880170,"results":"25","hashOfConfig":"15"},{"size":56114,"mtime":1608817087227,"results":"26","hashOfConfig":"15"},{"size":1277,"mtime":1609258787678,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"1uufhjc",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":36,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"40"},{"filePath":"41","messages":"42","errorCount":104,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"40"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"R:\\react_app\\myapp\\src\\index.js",[],["58","59"],"R:\\react_app\\myapp\\src\\reportWebVitals.js",[],"R:\\react_app\\myapp\\src\\App.js",[],"R:\\react_app\\myapp\\src\\components\\test.js",[],"R:\\react_app\\myapp\\src\\components\\OrbitControls.js",["60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98"],"/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\n\nTHREE.OrbitControls = function ( object, domElement ) {\n\n\tthis.object = object;\n\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = - Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.25;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn spherical.phi;\n\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn spherical.theta;\n\n\t};\n\n\tthis.saveState = function () {\n\n\t\tscope.target0.copy( scope.target );\n\t\tscope.position0.copy( scope.object.position );\n\t\tscope.zoom0 = scope.object.zoom;\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tscope.target.copy( scope.target0 );\n\t\tscope.object.position.copy( scope.position0 );\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent( changeEvent );\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\n\t};\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\tvar quatInverse = quat.clone().inverse();\n\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\treturn function update() {\n\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3( offset );\n\n\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t}\n\n\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\tspherical.makeSafe();\n\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t// move target to panned location\n\t\t\tscope.target.add( panOffset );\n\n\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t} else {\n\n\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\tscale = 1;\n\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif ( zoomChanged ||\n\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t}();\n\n\tthis.dispose = function () {\n\n\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction rotateLeft( angle ) {\n\n\t\tsphericalDelta.theta -= angle;\n\n\t}\n\n\tfunction rotateUp( angle ) {\n\n\t\tsphericalDelta.phi -= angle;\n\n\t}\n\n\tvar panLeft = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\tv.multiplyScalar( - distance );\n\n\t\t\tpanOffset.add( v );\n\n\t\t};\n\n\t}();\n\n\tvar panUp = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\tv.multiplyScalar( distance );\n\n\t\t\tpanOffset.add( v );\n\n\t\t};\n\n\t}();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\tscope.enablePan = false;\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\n\tfunction dollyIn( dollyScale ) {\n\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\tscale /= dollyScale;\n\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tscope.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\tfunction dollyOut( dollyScale ) {\n\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\tscale *= dollyScale;\n\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tscope.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate( event ) {\n\n\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\trotateStart.set( event.clientX, event.clientY );\n\n\t}\n\n\tfunction handleMouseDownDolly( event ) {\n\n\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t}\n\n\tfunction handleMouseDownPan( event ) {\n\n\t\t//console.log( 'handleMouseDownPan' );\n\n\t\tpanStart.set( event.clientX, event.clientY );\n\n\t}\n\n\tfunction handleMouseMoveRotate( event ) {\n\n\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\trotateEnd.set( event.clientX, event.clientY );\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t// rotating across whole screen goes 360 degrees around\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\trotateStart.copy( rotateEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseMoveDolly( event ) {\n\n\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\tdollyIn( getZoomScale() );\n\n\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\tdollyOut( getZoomScale() );\n\n\t\t}\n\n\t\tdollyStart.copy( dollyEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseMovePan( event ) {\n\n\t\t//console.log( 'handleMouseMovePan' );\n\n\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\tpan( panDelta.x, panDelta.y );\n\n\t\tpanStart.copy( panEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseUp( event ) {\n\n\t\t// console.log( 'handleMouseUp' );\n\n\t}\n\n\tfunction handleMouseWheel( event ) {\n\n\t\t// console.log( 'handleMouseWheel' );\n\n\t\tif ( event.deltaY < 0 ) {\n\n\t\t\tdollyOut( getZoomScale() );\n\n\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\tdollyIn( getZoomScale() );\n\n\t\t}\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleKeyDown( event ) {\n\n\t\t//console.log( 'handleKeyDown' );\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction handleTouchStartRotate( event ) {\n\n\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t}\n\n\tfunction handleTouchStartDolly( event ) {\n\n\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\tdollyStart.set( 0, distance );\n\n\t}\n\n\tfunction handleTouchStartPan( event ) {\n\n\t\t//console.log( 'handleTouchStartPan' );\n\n\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t}\n\n\tfunction handleTouchMoveRotate( event ) {\n\n\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t// rotating across whole screen goes 360 degrees around\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\trotateStart.copy( rotateEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleTouchMoveDolly( event ) {\n\n\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\tdollyEnd.set( 0, distance );\n\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\tdollyOut( getZoomScale() );\n\n\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\tdollyIn( getZoomScale() );\n\n\t\t}\n\n\t\tdollyStart.copy( dollyEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleTouchMovePan( event ) {\n\n\t\t//console.log( 'handleTouchMovePan' );\n\n\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\tpan( panDelta.x, panDelta.y );\n\n\t\tpanStart.copy( panEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleTouchEnd( event ) {\n\n\t\t//console.log( 'handleTouchEnd' );\n\n\t}\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch ( event.button ) {\n\n\t\t\tcase scope.mouseButtons.ORBIT:\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.ZOOM:\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.PAN:\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) {\n\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t}\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch ( state ) {\n\n\t\t\tcase STATE.ROTATE:\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.DOLLY:\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.PAN:\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction onMouseUp( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\thandleMouseUp( event );\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\tscope.dispatchEvent( endEvent );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\thandleMouseWheel( event );\n\n\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\tscope.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\thandleKeyDown( event );\n\n\t}\n\n\tfunction onTouchStart( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleTouchStartDolly( event );\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) {\n\n\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t}\n\n\t}\n\n\tfunction onTouchMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\n\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\n\t\t\t\thandleTouchMoveDolly( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\n\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction onTouchEnd( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\thandleTouchEnd( event );\n\n\t\tscope.dispatchEvent( endEvent );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onContextMenu( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t// force an update at start\n\n\tthis.update();\n\n};\n\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\nObject.defineProperties( THREE.OrbitControls.prototype, {\n\n\tcenter: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\treturn this.target;\n\n\t\t}\n\n\t},\n\n\t// backward compatibility\n\n\tnoZoom: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\treturn ! this.enableZoom;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\tthis.enableZoom = ! value;\n\n\t\t}\n\n\t},\n\n\tnoRotate: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\treturn ! this.enableRotate;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\tthis.enableRotate = ! value;\n\n\t\t}\n\n\t},\n\n\tnoPan: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\treturn ! this.enablePan;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\tthis.enablePan = ! value;\n\n\t\t}\n\n\t},\n\n\tnoKeys: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\treturn ! this.enableKeys;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\tthis.enableKeys = ! value;\n\n\t\t}\n\n\t},\n\n\tstaticMoving: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\treturn ! this.enableDamping;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\tthis.enableDamping = ! value;\n\n\t\t}\n\n\t},\n\n\tdynamicDampingFactor: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\treturn this.dampingFactor;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\tthis.dampingFactor = value;\n\n\t\t}\n\n\t}\n\n} );",["99","100"],"R:\\react_app\\myapp\\src\\components\\GLTFLoader.js",["101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228"],"THREE.GLTFLoader = ( function () {\r\n\r\n\tfunction GLTFLoader( manager ) {\r\n\r\n\t\tTHREE.Loader.call( this, manager );\r\n\r\n\t\tthis.dracoLoader = null;\r\n\t\tthis.ddsLoader = null;\r\n\t\tthis.ktx2Loader = null;\r\n\t\tthis.meshoptDecoder = null;\r\n\r\n\t\tthis.pluginCallbacks = [];\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureWebPExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFLightsExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMeshoptCompression( parser );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tGLTFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\r\n\r\n\t\tconstructor: GLTFLoader,\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar resourcePath;\r\n\r\n\t\t\tif ( this.resourcePath !== '' ) {\r\n\r\n\t\t\t\tresourcePath = this.resourcePath;\r\n\r\n\t\t\t} else if ( this.path !== '' ) {\r\n\r\n\t\t\t\tresourcePath = this.path;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresourcePath = THREE.LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\r\n\t\t\t// the model is fully loaded. This means the count of items loaded will\r\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\r\n\t\t\tthis.manager.itemStart( url );\r\n\r\n\t\t\tvar _onError = function ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\r\n\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\r\n\r\n\t\t\t\t\t\tonLoad( gltf );\r\n\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t\t}, _onError );\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\t_onError( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, _onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetDRACOLoader: function ( dracoLoader ) {\r\n\r\n\t\t\tthis.dracoLoader = dracoLoader;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetDDSLoader: function ( ddsLoader ) {\r\n\r\n\t\t\tthis.ddsLoader = ddsLoader;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetKTX2Loader: function ( ktx2Loader ) {\r\n\r\n\t\t\tthis.ktx2Loader = ktx2Loader;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetMeshoptDecoder: function ( meshoptDecoder ) {\r\n\r\n\t\t\tthis.meshoptDecoder = meshoptDecoder;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tregister: function ( callback ) {\r\n\r\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\r\n\r\n\t\t\t\tthis.pluginCallbacks.push( callback );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tunregister: function ( callback ) {\r\n\r\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\r\n\r\n\t\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( data, path, onLoad, onError ) {\r\n\r\n\t\t\tvar content;\r\n\t\t\tvar extensions = {};\r\n\t\t\tvar plugins = {};\r\n\r\n\t\t\tif ( typeof data === 'string' ) {\r\n\r\n\t\t\t\tcontent = data;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\r\n\r\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\r\n\r\n\t\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\t\tif ( onError ) onError( error );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar json = JSON.parse( content );\r\n\r\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\r\n\r\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parser = new GLTFParser( json, {\r\n\r\n\t\t\t\tpath: path || this.resourcePath || '',\r\n\t\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\t\tmanager: this.manager,\r\n\t\t\t\tktx2Loader: this.ktx2Loader,\r\n\t\t\t\tmeshoptDecoder: this.meshoptDecoder\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\r\n\r\n\t\t\tfor ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {\r\n\r\n\t\t\t\tvar plugin = this.pluginCallbacks[ i ]( parser );\r\n\t\t\t\tplugins[ plugin.name ] = plugin;\r\n\r\n\t\t\t\t// Workaround to avoid determining as unknown extension\r\n\t\t\t\t// in addUnknownExtensionsToUserData().\r\n\t\t\t\t// Remove this workaround if we move all the existing\r\n\t\t\t\t// extension handlers to plugin system\r\n\t\t\t\textensions[ plugin.name ] = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.extensionsUsed ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\r\n\r\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\r\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\r\n\r\n\t\t\t\t\tswitch ( extensionName ) {\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.MSFT_TEXTURE_DDS:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureDDSExtension( this.ddsLoader );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.setExtensions( extensions );\r\n\t\t\tparser.setPlugins( plugins );\r\n\t\t\tparser.parse( onLoad, onError );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t/* GLTFREGISTRY */\r\n\r\n\tfunction GLTFRegistry() {\r\n\r\n\t\tvar objects = {};\r\n\r\n\t\treturn\t{\r\n\r\n\t\t\tget: function ( key ) {\r\n\r\n\t\t\t\treturn objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tadd: function ( key, object ) {\r\n\r\n\t\t\t\tobjects[ key ] = object;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremove: function ( key ) {\r\n\r\n\t\t\t\tdelete objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremoveAll: function () {\r\n\r\n\t\t\t\tobjects = {};\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/*********************************/\r\n\t/********** EXTENSIONS ***********/\r\n\t/*********************************/\r\n\r\n\tvar EXTENSIONS = {\r\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\r\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\r\n\t\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\r\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n\t\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\r\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\r\n\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\r\n\t\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\r\n\t\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\r\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\r\n\t};\r\n\r\n\t/**\r\n\t * DDS Texture Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\r\n\t *\r\n\t */\r\n\tfunction GLTFTextureDDSExtension( ddsLoader ) {\r\n\r\n\t\tif ( ! ddsLoader ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\r\n\t\tthis.ddsLoader = ddsLoader;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Punctual Lights Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n\t */\r\n\tfunction GLTFLightsExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.cache = { refs: {}, uses: {} };\r\n\r\n\t}\r\n\r\n\tGLTFLightsExtension.prototype._markDefs = function () {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar nodeDefs = this.parser.json.nodes || [];\r\n\r\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.extensions\r\n\t\t\t\t&& nodeDef.extensions[ this.name ]\r\n\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\r\n\r\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tGLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar cacheKey = 'light:' + lightIndex;\r\n\t\tvar dependency = parser.cache.get( cacheKey );\r\n\r\n\t\tif ( dependency ) return dependency;\r\n\r\n\t\tvar json = parser.json;\r\n\t\tvar extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\r\n\t\tvar lightDefs = extensions.lights || [];\r\n\t\tvar lightDef = lightDefs[ lightIndex ];\r\n\t\tvar lightNode;\r\n\r\n\t\tvar color = new THREE.Color( 0xffffff );\r\n\r\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\r\n\r\n\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n\t\tswitch ( lightDef.type ) {\r\n\r\n\t\t\tcase 'directional':\r\n\t\t\t\tlightNode = new THREE.DirectionalLight( color );\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'point':\r\n\t\t\t\tlightNode = new THREE.PointLight( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'spot':\r\n\t\t\t\tlightNode = new THREE.SpotLight( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t// Handle spotlight properties.\r\n\t\t\t\tlightDef.spot = lightDef.spot || {};\r\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' );\r\n\r\n\t\t}\r\n\r\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n\t\t// here, because node-level parsing will only override position if explicitly specified.\r\n\t\tlightNode.position.set( 0, 0, 0 );\r\n\r\n\t\tlightNode.decay = 2;\r\n\r\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\r\n\r\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\r\n\r\n\t\tdependency = Promise.resolve( lightNode );\r\n\r\n\t\tparser.cache.add( cacheKey, dependency );\r\n\r\n\t\treturn dependency;\r\n\r\n\t};\r\n\r\n\tGLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {\r\n\r\n\t\tvar self = this;\r\n\t\tvar parser = this.parser;\r\n\t\tvar json = parser.json;\r\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\r\n\t\tvar lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\r\n\t\tvar lightIndex = lightDef.light;\r\n\r\n\t\tif ( lightIndex === undefined ) return null;\r\n\r\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\r\n\r\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Unlit Materials Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n\t */\r\n\tfunction GLTFMaterialsUnlitExtension() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\r\n\r\n\t\treturn THREE.MeshBasicMaterial;\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\r\n\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n\t\tif ( metallicRoughness ) {\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Clearcoat Materials Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n\t */\r\n\tfunction GLTFMaterialsClearcoatExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tvar extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.clearcoatFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\r\n\r\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\r\n\r\n\t\t\t\tmaterialParams.clearcoatNormalScale = new THREE.Vector2( scale, scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Transmission Materials Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n\t * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n\t */\r\n\tfunction GLTFMaterialsTransmissionExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tvar extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.transmissionFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.transmissionTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * BasisU Texture Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n\t */\r\n\tfunction GLTFTextureBasisUExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n\r\n\t}\r\n\r\n\tGLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar json = parser.json;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar extension = textureDef.extensions[ this.name ];\r\n\t\tvar source = json.images[ extension.source ];\r\n\t\tvar loader = parser.options.ktx2Loader;\r\n\r\n\t\tif ( ! loader ) {\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * WebP Texture Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n\t */\r\n\tfunction GLTFTextureWebPExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n\t\tthis.isSupported = null;\r\n\r\n\t}\r\n\r\n\tGLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar name = this.name;\r\n\t\tvar parser = this.parser;\r\n\t\tvar json = parser.json;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar extension = textureDef.extensions[ name ];\r\n\t\tvar source = json.images[ extension.source ];\r\n\t\tvar loader = source.uri ? parser.options.manager.getHandler( source.uri ) : parser.textureLoader;\r\n\r\n\t\treturn this.detectSupport().then( function ( isSupported ) {\r\n\r\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Fall back to PNG or JPEG.\r\n\t\t\treturn parser.loadTexture( textureIndex );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFTextureWebPExtension.prototype.detectSupport = function () {\r\n\r\n\t\tif ( ! this.isSupported ) {\r\n\r\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tvar image = new Image();\r\n\r\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\r\n\t\t\t\t// WebP images, unfortunately.\r\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\r\n\r\n\t\t\t\timage.onload = image.onerror = function () {\r\n\r\n\t\t\t\t\tresolve( image.height === 1 );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isSupported;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t* meshopt BufferView Compression Extension\r\n\t*\r\n\t* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n\t*/\r\n\tfunction GLTFMeshoptCompression( parser ) {\r\n\r\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n\t\tthis.parser = parser;\r\n\r\n\t}\r\n\r\n\tGLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {\r\n\r\n\t\tvar json = this.parser.json;\r\n\t\tvar bufferView = json.bufferViews[ index ];\r\n\r\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\r\n\r\n\t\t\tvar extensionDef = bufferView.extensions[ this.name ];\r\n\r\n\t\t\tvar buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\r\n\t\t\tvar decoder = this.parser.options.meshoptDecoder;\r\n\r\n\t\t\tif ( ! decoder || ! decoder.supported ) {\r\n\r\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\r\n\r\n\t\t\t\tvar byteOffset = extensionDef.byteOffset || 0;\r\n\t\t\t\tvar byteLength = extensionDef.byteLength || 0;\r\n\r\n\t\t\t\tvar count = extensionDef.count;\r\n\t\t\t\tvar stride = extensionDef.byteStride;\r\n\r\n\t\t\t\tvar result = new ArrayBuffer( count * stride );\r\n\t\t\t\tvar source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\r\n\r\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t/* BINARY EXTENSION */\r\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\r\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\r\n\r\n\tfunction GLTFBinaryExtension( data ) {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\t\tthis.content = null;\r\n\t\tthis.body = null;\r\n\r\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\r\n\r\n\t\tthis.header = {\r\n\t\t\tmagic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\r\n\t\t\tversion: headerView.getUint32( 4, true ),\r\n\t\t\tlength: headerView.getUint32( 8, true )\r\n\t\t};\r\n\r\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\r\n\r\n\t\t} else if ( this.header.version < 2.0 ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\r\n\t\tvar chunkIndex = 0;\r\n\r\n\t\twhile ( chunkIndex < chunkView.byteLength ) {\r\n\r\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\r\n\r\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\r\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText( contentArray );\r\n\r\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\r\n\r\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Clients must ignore chunks with unknown types.\r\n\r\n\t\t\tchunkIndex += chunkLength;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.content === null ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * DRACO Mesh Compression Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n\t */\r\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\r\n\r\n\t\tif ( ! dracoLoader ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n\t\tthis.json = json;\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\t\tthis.dracoLoader.preload();\r\n\r\n\t}\r\n\r\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar dracoLoader = this.dracoLoader;\r\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\r\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\r\n\t\tvar threeAttributeMap = {};\r\n\t\tvar attributeNormalizedMap = {};\r\n\t\tvar attributeTypeMap = {};\r\n\r\n\t\tfor ( var attributeName in gltfAttributeMap ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( attributeName in primitive.attributes ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\r\n\r\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\r\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\r\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\r\n\r\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\r\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\r\n\r\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresolve( geometry );\r\n\r\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Texture Transform Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n\t */\r\n\tfunction GLTFTextureTransformExtension() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n\r\n\t}\r\n\r\n\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\r\n\r\n\t\ttexture = texture.clone();\r\n\r\n\t\tif ( transform.offset !== undefined ) {\r\n\r\n\t\t\ttexture.offset.fromArray( transform.offset );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.rotation !== undefined ) {\r\n\r\n\t\t\ttexture.rotation = transform.rotation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.scale !== undefined ) {\r\n\r\n\t\t\ttexture.repeat.fromArray( transform.scale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.texCoord !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\r\n\r\n\t\t}\r\n\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specular-Glossiness Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n\t */\r\n\r\n\t/**\r\n\t * A sub class of THREE.StandardMaterial with some of the functionality\r\n\t * changed via the `onBeforeCompile` callback\r\n\t * @pailhead\r\n\t */\r\n\r\n\tfunction GLTFMeshStandardSGMaterial( params ) {\r\n\r\n\t\tTHREE.MeshStandardMaterial.call( this );\r\n\r\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\r\n\r\n\t\t//various chunks that need replacing\r\n\t\tvar specularMapParsFragmentChunk = [\r\n\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t'\tuniform sampler2D specularMap;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar glossinessMapParsFragmentChunk = [\r\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t'\tuniform sampler2D glossinessMap;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar specularMapFragmentChunk = [\r\n\t\t\t'vec3 specularFactor = specular;',\r\n\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\r\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\r\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar glossinessMapFragmentChunk = [\r\n\t\t\t'float glossinessFactor = glossiness;',\r\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\r\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar lightPhysicalFragmentChunk = [\r\n\t\t\t'PhysicalMaterial material;',\r\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\r\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\r\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\r\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\r\n\t\t\t'material.specularRoughness += geometryRoughness;',\r\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\r\n\t\t\t'material.specularColor = specularFactor;',\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar uniforms = {\r\n\t\t\tspecular: { value: new THREE.Color().setHex( 0xffffff ) },\r\n\t\t\tglossiness: { value: 1 },\r\n\t\t\tspecularMap: { value: null },\r\n\t\t\tglossinessMap: { value: null }\r\n\t\t};\r\n\r\n\t\tthis._extraUniforms = uniforms;\r\n\r\n\t\tthis.onBeforeCompile = function ( shader ) {\r\n\r\n\t\t\tfor ( var uniformName in uniforms ) {\r\n\r\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshader.fragmentShader = shader.fragmentShader\r\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\r\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\r\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\r\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\r\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\r\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\r\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\r\n\r\n\t\t};\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\tspecular: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.specular.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.specular.value = v;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tspecularMap: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.specularMap.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.specularMap.value = v;\r\n\r\n\t\t\t\t\tif ( v ) {\r\n\r\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tglossiness: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.glossiness.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.glossiness.value = v;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tglossinessMap: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.glossinessMap.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.glossinessMap.value = v;\r\n\r\n\t\t\t\t\tif ( v ) {\r\n\r\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\r\n\t\t\t\t\t\tthis.defines.USE_UV = '';\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\r\n\t\t\t\t\t\tdelete this.defines.USE_UV;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tdelete this.metalness;\r\n\t\tdelete this.roughness;\r\n\t\tdelete this.metalnessMap;\r\n\t\tdelete this.roughnessMap;\r\n\r\n\t\tthis.setValues( params );\r\n\r\n\t}\r\n\r\n\tGLTFMeshStandardSGMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\r\n\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\r\n\r\n\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\r\n\r\n\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\tthis.specular.copy( source.specular );\r\n\t\tthis.glossinessMap = source.glossinessMap;\r\n\t\tthis.glossiness = source.glossiness;\r\n\t\tdelete this.metalness;\r\n\t\tdelete this.roughness;\r\n\t\tdelete this.metalnessMap;\r\n\t\tdelete this.roughnessMap;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\r\n\r\n\t\t\tspecularGlossinessParams: [\r\n\t\t\t\t'color',\r\n\t\t\t\t'map',\r\n\t\t\t\t'lightMap',\r\n\t\t\t\t'lightMapIntensity',\r\n\t\t\t\t'aoMap',\r\n\t\t\t\t'aoMapIntensity',\r\n\t\t\t\t'emissive',\r\n\t\t\t\t'emissiveIntensity',\r\n\t\t\t\t'emissiveMap',\r\n\t\t\t\t'bumpMap',\r\n\t\t\t\t'bumpScale',\r\n\t\t\t\t'normalMap',\r\n\t\t\t\t'normalMapType',\r\n\t\t\t\t'displacementMap',\r\n\t\t\t\t'displacementScale',\r\n\t\t\t\t'displacementBias',\r\n\t\t\t\t'specularMap',\r\n\t\t\t\t'specular',\r\n\t\t\t\t'glossinessMap',\r\n\t\t\t\t'glossiness',\r\n\t\t\t\t'alphaMap',\r\n\t\t\t\t'envMap',\r\n\t\t\t\t'envMapIntensity',\r\n\t\t\t\t'refractionRatio',\r\n\t\t\t],\r\n\r\n\t\t\tgetMaterialType: function () {\r\n\r\n\t\t\t\treturn GLTFMeshStandardSGMaterial;\r\n\r\n\t\t\t},\r\n\r\n\t\t\textendParams: function ( materialParams, materialDef, parser ) {\r\n\r\n\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\r\n\r\n\t\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\r\n\t\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\t\tvar pending = [];\r\n\r\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\r\n\r\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\r\n\r\n\t\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\r\n\r\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );\r\n\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n\t\t\t\tmaterialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );\r\n\r\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\r\n\r\n\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\r\n\r\n\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\r\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\r\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all( pending );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tcreateMaterial: function ( materialParams ) {\r\n\r\n\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\r\n\t\t\t\tmaterial.fog = true;\r\n\r\n\t\t\t\tmaterial.color = materialParams.color;\r\n\r\n\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\r\n\r\n\t\t\t\tmaterial.lightMap = null;\r\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\r\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.emissive = materialParams.emissive;\r\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\r\n\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\r\n\r\n\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\r\n\t\t\t\tmaterial.bumpScale = 1;\r\n\r\n\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\r\n\t\t\t\tmaterial.normalMapType = THREE.TangentSpaceNormalMap;\r\n\r\n\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\r\n\r\n\t\t\t\tmaterial.displacementMap = null;\r\n\t\t\t\tmaterial.displacementScale = 1;\r\n\t\t\t\tmaterial.displacementBias = 0;\r\n\r\n\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\r\n\t\t\t\tmaterial.specular = materialParams.specular;\r\n\r\n\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\r\n\t\t\t\tmaterial.glossiness = materialParams.glossiness;\r\n\r\n\t\t\t\tmaterial.alphaMap = null;\r\n\r\n\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\r\n\t\t\t\tmaterial.envMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.refractionRatio = 0.98;\r\n\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t},\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Mesh Quantization Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n\t */\r\n\tfunction GLTFMeshQuantizationExtension() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n\r\n\t}\r\n\r\n\t/*********************************/\r\n\t/********** INTERPOLATION ********/\r\n\t/*********************************/\r\n\r\n\t// Spline Interpolation\r\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\t}\r\n\r\n\tGLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );\r\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\r\n\r\n\t\t// Copies a sample value to the result buffer. See description of glTF\r\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tvalueSize = this.valueSize,\r\n\t\t\toffset = index * valueSize * 3 + valueSize;\r\n\r\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer;\r\n\t\tvar values = this.sampleValues;\r\n\t\tvar stride = this.valueSize;\r\n\r\n\t\tvar stride2 = stride * 2;\r\n\t\tvar stride3 = stride * 3;\r\n\r\n\t\tvar td = t1 - t0;\r\n\r\n\t\tvar p = ( t - t0 ) / td;\r\n\t\tvar pp = p * p;\r\n\t\tvar ppp = pp * p;\r\n\r\n\t\tvar offset1 = i1 * stride3;\r\n\t\tvar offset0 = offset1 - stride3;\r\n\r\n\t\tvar s2 = - 2 * ppp + 3 * pp;\r\n\t\tvar s3 = ppp - pp;\r\n\t\tvar s0 = 1 - s2;\r\n\t\tvar s1 = s3 - pp + p;\r\n\r\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\r\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\r\n\r\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\r\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\r\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\r\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t/*********************************/\r\n\t/********** INTERNALS ************/\r\n\t/*********************************/\r\n\r\n\t/* CONSTANTS */\r\n\r\n\tvar WEBGL_CONSTANTS = {\r\n\t\tFLOAT: 5126,\r\n\t\t//FLOAT_MAT2: 35674,\r\n\t\tFLOAT_MAT3: 35675,\r\n\t\tFLOAT_MAT4: 35676,\r\n\t\tFLOAT_VEC2: 35664,\r\n\t\tFLOAT_VEC3: 35665,\r\n\t\tFLOAT_VEC4: 35666,\r\n\t\tLINEAR: 9729,\r\n\t\tREPEAT: 10497,\r\n\t\tSAMPLER_2D: 35678,\r\n\t\tPOINTS: 0,\r\n\t\tLINES: 1,\r\n\t\tLINE_LOOP: 2,\r\n\t\tLINE_STRIP: 3,\r\n\t\tTRIANGLES: 4,\r\n\t\tTRIANGLE_STRIP: 5,\r\n\t\tTRIANGLE_FAN: 6,\r\n\t\tUNSIGNED_BYTE: 5121,\r\n\t\tUNSIGNED_SHORT: 5123\r\n\t};\r\n\r\n\tvar WEBGL_COMPONENT_TYPES = {\r\n\t\t5120: Int8Array,\r\n\t\t5121: Uint8Array,\r\n\t\t5122: Int16Array,\r\n\t\t5123: Uint16Array,\r\n\t\t5125: Uint32Array,\r\n\t\t5126: Float32Array\r\n\t};\r\n\r\n\tvar WEBGL_FILTERS = {\r\n\t\t9728: THREE.NearestFilter,\r\n\t\t9729: THREE.LinearFilter,\r\n\t\t9984: THREE.NearestMipmapNearestFilter,\r\n\t\t9985: THREE.LinearMipmapNearestFilter,\r\n\t\t9986: THREE.NearestMipmapLinearFilter,\r\n\t\t9987: THREE.LinearMipmapLinearFilter\r\n\t};\r\n\r\n\tvar WEBGL_WRAPPINGS = {\r\n\t\t33071: THREE.ClampToEdgeWrapping,\r\n\t\t33648: THREE.MirroredRepeatWrapping,\r\n\t\t10497: THREE.RepeatWrapping\r\n\t};\r\n\r\n\tvar WEBGL_TYPE_SIZES = {\r\n\t\t'SCALAR': 1,\r\n\t\t'VEC2': 2,\r\n\t\t'VEC3': 3,\r\n\t\t'VEC4': 4,\r\n\t\t'MAT2': 4,\r\n\t\t'MAT3': 9,\r\n\t\t'MAT4': 16\r\n\t};\r\n\r\n\tvar ATTRIBUTES = {\r\n\t\tPOSITION: 'position',\r\n\t\tNORMAL: 'normal',\r\n\t\tTANGENT: 'tangent',\r\n\t\tTEXCOORD_0: 'uv',\r\n\t\tTEXCOORD_1: 'uv2',\r\n\t\tCOLOR_0: 'color',\r\n\t\tWEIGHTS_0: 'skinWeight',\r\n\t\tJOINTS_0: 'skinIndex',\r\n\t};\r\n\r\n\tvar PATH_PROPERTIES = {\r\n\t\tscale: 'scale',\r\n\t\ttranslation: 'position',\r\n\t\trotation: 'quaternion',\r\n\t\tweights: 'morphTargetInfluences'\r\n\t};\r\n\r\n\tvar INTERPOLATION = {\r\n\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\r\n\t\tLINEAR: THREE.InterpolateLinear,\r\n\t\tSTEP: THREE.InterpolateDiscrete\r\n\t};\r\n\r\n\tvar ALPHA_MODES = {\r\n\t\tOPAQUE: 'OPAQUE',\r\n\t\tMASK: 'MASK',\r\n\t\tBLEND: 'BLEND'\r\n\t};\r\n\r\n\t/* UTILITY FUNCTIONS */\r\n\r\n\tfunction resolveURL( url, path ) {\r\n\r\n\t\t// Invalid URL\r\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\r\n\r\n\t\t// Host Relative URL\r\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\r\n\r\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\r\n\r\n\t\t}\r\n\r\n\t\t// Absolute URL http://,https://,//\r\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\r\n\r\n\t\t// Data URI\r\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\r\n\r\n\t\t// Blob URL\r\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\r\n\r\n\t\t// Relative URL\r\n\t\treturn path + url;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n\t */\r\n\tfunction createDefaultMaterial( cache ) {\r\n\r\n\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\r\n\r\n\t\t\tcache[ 'DefaultMaterial' ] = new THREE.MeshStandardMaterial( {\r\n\t\t\t\tcolor: 0xFFFFFF,\r\n\t\t\t\temissive: 0x000000,\r\n\t\t\t\tmetalness: 1,\r\n\t\t\t\troughness: 1,\r\n\t\t\t\ttransparent: false,\r\n\t\t\t\tdepthTest: true,\r\n\t\t\t\tside: THREE.FrontSide\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn cache[ 'DefaultMaterial' ];\r\n\r\n\t}\r\n\r\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\r\n\r\n\t\t// Add unknown glTF extensions to an object's userData.\r\n\r\n\t\tfor ( var name in objectDef.extensions ) {\r\n\r\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\r\n\r\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\r\n\t * @param {GLTF.definition} gltfDef\r\n\t */\r\n\tfunction assignExtrasToUserData( object, gltfDef ) {\r\n\r\n\t\tif ( gltfDef.extras !== undefined ) {\r\n\r\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\r\n\r\n\t\t\t\tObject.assign( object.userData, gltfDef.extras );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n\t *\r\n\t * @param {THREE.BufferGeometry} geometry\r\n\t * @param {Array<GLTF.Target>} targets\r\n\t * @param {GLTFParser} parser\r\n\t * @return {Promise<THREE.BufferGeometry>}\r\n\t */\r\n\tfunction addMorphTargets( geometry, targets, parser ) {\r\n\r\n\t\tvar hasMorphPosition = false;\r\n\t\tvar hasMorphNormal = false;\r\n\r\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\r\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\r\n\r\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\r\n\r\n\t\tvar pendingPositionAccessors = [];\r\n\t\tvar pendingNormalAccessors = [];\r\n\r\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\tif ( hasMorphPosition ) {\r\n\r\n\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\r\n\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\r\n\t\t\t\t\t: geometry.attributes.position;\r\n\r\n\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasMorphNormal ) {\r\n\r\n\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\r\n\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\r\n\t\t\t\t\t: geometry.attributes.normal;\r\n\r\n\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\t\t\tPromise.all( pendingPositionAccessors ),\r\n\t\t\tPromise.all( pendingNormalAccessors )\r\n\t\t] ).then( function ( accessors ) {\r\n\r\n\t\t\tvar morphPositions = accessors[ 0 ];\r\n\t\t\tvar morphNormals = accessors[ 1 ];\r\n\r\n\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\r\n\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\r\n\t\t\tgeometry.morphTargetsRelative = true;\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.Mesh} mesh\r\n\t * @param {GLTF.Mesh} meshDef\r\n\t */\r\n\tfunction updateMorphTargets( mesh, meshDef ) {\r\n\r\n\t\tmesh.updateMorphTargets();\r\n\r\n\t\tif ( meshDef.weights !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\r\n\r\n\t\t\tvar targetNames = meshDef.extras.targetNames;\r\n\r\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\r\n\r\n\t\t\t\tmesh.morphTargetDictionary = {};\r\n\r\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createPrimitiveKey( primitiveDef ) {\r\n\r\n\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\r\n\t\tvar geometryKey;\r\n\r\n\t\tif ( dracoExtension ) {\r\n\r\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\r\n\t\t\t\t+ ':' + dracoExtension.indices\r\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\r\n\r\n\t\t}\r\n\r\n\t\treturn geometryKey;\r\n\r\n\t}\r\n\r\n\tfunction createAttributesKey( attributes ) {\r\n\r\n\t\tvar attributesKey = '';\r\n\r\n\t\tvar keys = Object.keys( attributes ).sort();\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\r\n\r\n\t\t}\r\n\r\n\t\treturn attributesKey;\r\n\r\n\t}\r\n\r\n\t/* GLTF PARSER */\r\n\r\n\tfunction GLTFParser( json, options ) {\r\n\r\n\t\tthis.json = json || {};\r\n\t\tthis.extensions = {};\r\n\t\tthis.plugins = {};\r\n\t\tthis.options = options || {};\r\n\r\n\t\t// loader object cache\r\n\t\tthis.cache = new GLTFRegistry();\r\n\r\n\t\t// associations between Three.js objects and glTF elements\r\n\t\tthis.associations = new Map();\r\n\r\n\t\t// BufferGeometry caching\r\n\t\tthis.primitiveCache = {};\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.meshCache = { refs: {}, uses: {} };\r\n\t\tthis.cameraCache = { refs: {}, uses: {} };\r\n\t\tthis.lightCache = { refs: {}, uses: {} };\r\n\r\n\t\t// Track node names, to ensure no duplicates\r\n\t\tthis.nodeNamesUsed = {};\r\n\r\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\r\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\r\n\r\n\t\t\tthis.textureLoader = new THREE.ImageBitmapLoader( this.options.manager );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.textureLoader = new THREE.TextureLoader( this.options.manager );\r\n\r\n\t\t}\r\n\r\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\r\n\r\n\t\tthis.fileLoader = new THREE.FileLoader( this.options.manager );\r\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\r\n\r\n\t\t\tthis.fileLoader.setWithCredentials( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tGLTFParser.prototype.setExtensions = function ( extensions ) {\r\n\r\n\t\tthis.extensions = extensions;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.setPlugins = function ( plugins ) {\r\n\r\n\t\tthis.plugins = plugins;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\r\n\t\t// Clear the loader cache\r\n\t\tthis.cache.removeAll();\r\n\r\n\t\t// Mark the special nodes/meshes in json for efficient parse\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext._markDefs && ext._markDefs();\r\n\r\n\t\t} );\r\n\r\n\t\tPromise.all( [\r\n\r\n\t\t\tthis.getDependencies( 'scene' ),\r\n\t\t\tthis.getDependencies( 'animation' ),\r\n\t\t\tthis.getDependencies( 'camera' ),\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar result = {\r\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\r\n\t\t\t\tscenes: dependencies[ 0 ],\r\n\t\t\t\tanimations: dependencies[ 1 ],\r\n\t\t\t\tcameras: dependencies[ 2 ],\r\n\t\t\t\tasset: json.asset,\r\n\t\t\t\tparser: parser,\r\n\t\t\t\tuserData: {}\r\n\t\t\t};\r\n\r\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\r\n\r\n\t\t\tassignExtrasToUserData( result, json );\r\n\r\n\t\t\tonLoad( result );\r\n\r\n\t\t} ).catch( onError );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Marks the special nodes/meshes in json for efficient parse.\r\n\t */\r\n\tGLTFParser.prototype._markDefs = function () {\r\n\r\n\t\tvar nodeDefs = this.json.nodes || [];\r\n\t\tvar skinDefs = this.json.skins || [];\r\n\t\tvar meshDefs = this.json.meshes || [];\r\n\r\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\r\n\t\t// Object3D. Use the skins' joint references to mark bones.\r\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\r\n\r\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\r\n\r\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Iterate over all nodes, marking references to shared resources,\r\n\t\t// as well as skeleton joints.\r\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\r\n\r\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\r\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\r\n\t\t\t\t// to mark SkinnedMesh if node has skin.\r\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\r\n\r\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Counts references to shared node / Object3D resources. These resources\r\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\r\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n\t * Textures) can be reused directly and are not marked here.\r\n\t *\r\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n\t */\r\n\tGLTFParser.prototype._addNodeRef = function ( cache, index ) {\r\n\r\n\t\tif ( index === undefined ) return;\r\n\r\n\t\tif ( cache.refs[ index ] === undefined ) {\r\n\r\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tcache.refs[ index ] ++;\r\n\r\n\t};\r\n\r\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\r\n\tGLTFParser.prototype._getNodeRef = function ( cache, index, object ) {\r\n\r\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\r\n\r\n\t\tvar ref = object.clone();\r\n\r\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\r\n\r\n\t\treturn ref;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype._invokeOne = function ( func ) {\r\n\r\n\t\tvar extensions = Object.values( this.plugins );\r\n\t\textensions.push( this );\r\n\r\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tvar result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) return result;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype._invokeAll = function ( func ) {\r\n\r\n\t\tvar extensions = Object.values( this.plugins );\r\n\t\textensions.unshift( this );\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tvar result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) pending.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn pending;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Requests the specified dependency asynchronously, with caching.\r\n\t * @param {string} type\r\n\t * @param {number} index\r\n\t * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\r\n\t */\r\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\r\n\r\n\t\tvar cacheKey = type + ':' + index;\r\n\t\tvar dependency = this.cache.get( cacheKey );\r\n\r\n\t\tif ( ! dependency ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'scene':\r\n\t\t\t\t\tdependency = this.loadScene( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'node':\r\n\t\t\t\t\tdependency = this.loadNode( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'mesh':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'accessor':\r\n\t\t\t\t\tdependency = this.loadAccessor( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bufferView':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'buffer':\r\n\t\t\t\t\tdependency = this.loadBuffer( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'material':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'texture':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'skin':\r\n\t\t\t\t\tdependency = this.loadSkin( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'animation':\r\n\t\t\t\t\tdependency = this.loadAnimation( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'camera':\r\n\t\t\t\t\tdependency = this.loadCamera( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cache.add( cacheKey, dependency );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependency;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Requests all dependencies of the specified type asynchronously, with caching.\r\n\t * @param {string} type\r\n\t * @return {Promise<Array<Object>>}\r\n\t */\r\n\tGLTFParser.prototype.getDependencies = function ( type ) {\r\n\r\n\t\tvar dependencies = this.cache.get( type );\r\n\r\n\t\tif ( ! dependencies ) {\r\n\r\n\t\t\tvar parser = this;\r\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\r\n\r\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\r\n\r\n\t\t\t\treturn parser.getDependency( type, index );\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t\tthis.cache.add( type, dependencies );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependencies;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t * @param {number} bufferIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\r\n\r\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\r\n\t\tvar loader = this.fileLoader;\r\n\r\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\t// If present, GLB container is required to be the first buffer.\r\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\r\n\r\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\r\n\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\r\n\r\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t * @param {number} bufferViewIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\r\n\r\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\r\n\r\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\r\n\r\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\r\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n\t * @param {number} accessorIndex\r\n\t * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\r\n\t */\r\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\r\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\r\n\r\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\r\n\r\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\r\n\t\t\t// information about attributes coming from another source (e.g. Draco\r\n\t\t\t// compression extension).\r\n\t\t\treturn Promise.resolve( null );\r\n\r\n\t\t}\r\n\r\n\t\tvar pendingBufferViews = [];\r\n\r\n\t\tif ( accessorDef.bufferView !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpendingBufferViews.push( null );\r\n\r\n\t\t}\r\n\r\n\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\r\n\r\n\t\t\tvar bufferView = bufferViews[ 0 ];\r\n\r\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\r\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\tvar itemBytes = elementBytes * itemSize;\r\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\r\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\r\n\t\t\tvar normalized = accessorDef.normalized === true;\r\n\t\t\tvar array, bufferAttribute;\r\n\r\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\r\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\r\n\r\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\r\n\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\r\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\r\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\r\n\r\n\t\t\t\tif ( ! ib ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\r\n\r\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\r\n\t\t\t\t\tib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );\r\n\r\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( bufferView === null ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\t\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\r\n\r\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\r\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\r\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\r\n\r\n\t\t\t\tif ( bufferView !== null ) {\r\n\r\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar index = sparseIndices[ i ];\r\n\r\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\r\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\r\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\r\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\r\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bufferAttribute;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n\t * @param {number} textureIndex\r\n\t * @return {Promise<THREE.Texture>}\r\n\t */\r\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar options = this.options;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tvar textureExtensions = textureDef.extensions || {};\r\n\r\n\t\tvar source;\r\n\r\n\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\r\n\r\n\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsource = json.images[ textureDef.source ];\r\n\r\n\t\t}\r\n\r\n\t\tvar loader;\r\n\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tloader = options.manager.getHandler( source.uri );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! loader ) {\r\n\r\n\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\r\n\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\r\n\t\t\t\t: this.textureLoader;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar options = this.options;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tvar URL = self.URL || self.webkitURL;\r\n\r\n\t\tvar sourceURI = source.uri;\r\n\t\tvar isObjectURL = false;\r\n\t\tvar hasAlpha = true;\r\n\r\n\t\tif ( source.mimeType === 'image/jpeg' ) hasAlpha = false;\r\n\r\n\t\tif ( source.bufferView !== undefined ) {\r\n\r\n\t\t\t// Load binary image data from bufferView, if provided.\r\n\r\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\r\n\r\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\r\n\r\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\r\n\t\t\t\t\t// alpha channel. This check is conservative  the image could have an alpha\r\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\r\n\t\t\t\t\t// sometimes contains alpha.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\r\n\t\t\t\t\tvar colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\r\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tisObjectURL = true;\r\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\r\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\r\n\t\t\t\treturn sourceURI;\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\t\tvar onLoad = resolve;\r\n\r\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\r\n\r\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\r\n\r\n\t\t\t\t\t\tresolve( new THREE.CanvasTexture( imageBitmap ) );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).then( function ( texture ) {\r\n\r\n\t\t\t// Clean up resources and configure Texture.\r\n\r\n\t\t\tif ( isObjectURL === true ) {\r\n\r\n\t\t\t\tURL.revokeObjectURL( sourceURI );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.flipY = false;\r\n\r\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\r\n\r\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\r\n\t\t\tif ( ! hasAlpha ) texture.format = THREE.RGBFormat;\r\n\r\n\t\t\tvar samplers = json.samplers || {};\r\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\r\n\r\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\r\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipmapLinearFilter;\r\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\r\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\r\n\r\n\t\t\tparser.associations.set( texture, {\r\n\t\t\t\ttype: 'textures',\r\n\t\t\t\tindex: textureIndex\r\n\t\t\t} );\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Asynchronously assigns a texture to the given material parameters.\r\n\t * @param {Object} materialParams\r\n\t * @param {string} mapName\r\n\t * @param {Object} mapDef\r\n\t * @return {Promise}\r\n\t */\r\n\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\r\n\r\n\t\tvar parser = this;\r\n\r\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\r\n\r\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\r\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\r\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\r\n\r\n\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\r\n\r\n\t\t\t\tif ( transform ) {\r\n\r\n\t\t\t\t\tvar gltfReference = parser.associations.get( texture );\r\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\r\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams[ mapName ] = texture;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\r\n\t * already has a material (generated from the glTF material options alone)\r\n\t * but reuse of the same glTF material may require multiple threejs materials\r\n\t * to accomodate different primitive types, defines, etc. New materials will\r\n\t * be created if necessary, and reused from a cache.\r\n\t * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\r\n\t */\r\n\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\r\n\r\n\t\tvar geometry = mesh.geometry;\r\n\t\tvar material = mesh.material;\r\n\r\n\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\r\n\t\tvar useVertexColors = geometry.attributes.color !== undefined;\r\n\t\tvar useFlatShading = geometry.attributes.normal === undefined;\r\n\t\tvar useSkinning = mesh.isSkinnedMesh === true;\r\n\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\r\n\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\r\n\r\n\t\tif ( mesh.isPoints ) {\r\n\r\n\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\r\n\r\n\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! pointsMaterial ) {\r\n\r\n\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\r\n\t\t\t\tTHREE.Material.prototype.copy.call( pointsMaterial, material );\r\n\t\t\t\tpointsMaterial.color.copy( material.color );\r\n\t\t\t\tpointsMaterial.map = material.map;\r\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = pointsMaterial;\r\n\r\n\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n\r\n\t\t\tvar lineMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! lineMaterial ) {\r\n\r\n\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\r\n\t\t\t\tTHREE.Material.prototype.copy.call( lineMaterial, material );\r\n\t\t\t\tlineMaterial.color.copy( material.color );\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = lineMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// Clone the material if it will be modified\r\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\r\n\r\n\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n\r\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\r\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\r\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\r\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\r\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\r\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\r\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\r\n\r\n\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! cachedMaterial ) {\r\n\r\n\t\t\t\tcachedMaterial = material.clone();\r\n\r\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\r\n\t\t\t\tif ( useVertexTangents ) cachedMaterial.vertexTangents = true;\r\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\r\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\r\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\r\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\r\n\r\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// workarounds for mesh and geometry\r\n\r\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\r\n\r\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\r\n\r\n\t\t}\r\n\r\n\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\tif ( material.normalScale && ! useVertexTangents ) {\r\n\r\n\t\t\tmaterial.normalScale.y = - material.normalScale.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.clearcoatNormalScale && ! useVertexTangents ) {\r\n\r\n\t\t\tmaterial.clearcoatNormalScale.y = - material.clearcoatNormalScale.y;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.material = material;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {\r\n\r\n\t\treturn THREE.MeshStandardMaterial;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n\t * @param {number} materialIndex\r\n\t * @return {Promise<THREE.Material>}\r\n\t */\r\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar materialDef = json.materials[ materialIndex ];\r\n\r\n\t\tvar materialType;\r\n\t\tvar materialParams = {};\r\n\t\tvar materialExtensions = materialDef.extensions || {};\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\r\n\r\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\r\n\t\t\tmaterialType = sgExtension.getMaterialType();\r\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\r\n\r\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\r\n\t\t\tmaterialType = kmuExtension.getMaterialType();\r\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Specification:\r\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\r\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\r\n\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\r\n\r\n\t\t\t} ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.doubleSided === true ) {\r\n\r\n\t\t\tmaterialParams.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\r\n\r\n\t\t\tmaterialParams.transparent = true;\r\n\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\r\n\t\t\tmaterialParams.depthWrite = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialParams.transparent = false;\r\n\r\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\r\n\r\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\r\n\r\n\t\t\tmaterialParams.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\r\n\r\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tmaterialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\tvar material;\r\n\r\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\r\n\r\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = new materialType( materialParams );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\r\n\r\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\r\n\t\t\tif ( material.map ) material.map.encoding = THREE.sRGBEncoding;\r\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;\r\n\r\n\t\t\tassignExtrasToUserData( material, materialDef );\r\n\r\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\r\n\r\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/** When Object3D instances are targeted by animation, they need unique names. */\r\n\tGLTFParser.prototype.createUniqueName = function ( originalName ) {\r\n\r\n\t\tvar name = THREE.PropertyBinding.sanitizeNodeName( originalName || '' );\r\n\r\n\t\tfor ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\r\n\r\n\t\t\tname = originalName + '_' + i;\r\n\r\n\t\t}\r\n\r\n\t\tthis.nodeNamesUsed[ name ] = true;\r\n\r\n\t\treturn name;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * @param {THREE.BufferGeometry} geometry\r\n\t * @param {GLTF.Primitive} primitiveDef\r\n\t * @param {GLTFParser} parser\r\n\t */\r\n\tfunction computeBounds( geometry, primitiveDef, parser ) {\r\n\r\n\t\tvar attributes = primitiveDef.attributes;\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\tif ( attributes.POSITION !== undefined ) {\r\n\r\n\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\r\n\r\n\t\t\tvar min = accessor.min;\r\n\t\t\tvar max = accessor.max;\r\n\r\n\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\t\tbox.set(\r\n\t\t\t\t\tnew THREE.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\r\n\t\t\t\t\tnew THREE.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar targets = primitiveDef.targets;\r\n\r\n\t\tif ( targets !== undefined ) {\r\n\r\n\t\t\tvar maxDisplacement = new THREE.Vector3();\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\t\tif ( target.POSITION !== undefined ) {\r\n\r\n\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\r\n\t\t\t\t\tvar min = accessor.min;\r\n\t\t\t\t\tvar max = accessor.max;\r\n\r\n\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\r\n\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\r\n\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\r\n\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\r\n\r\n\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n\t\t\t\t\t\tmaxDisplacement.max( vector );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n\t\t\tbox.expandByVector( maxDisplacement );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.boundingBox = box;\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\tbox.getCenter( sphere.center );\r\n\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\r\n\r\n\t\tgeometry.boundingSphere = sphere;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.BufferGeometry} geometry\r\n\t * @param {GLTF.Primitive} primitiveDef\r\n\t * @param {GLTFParser} parser\r\n\t * @return {Promise<THREE.BufferGeometry>}\r\n\t */\r\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\r\n\r\n\t\tvar attributes = primitiveDef.attributes;\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\r\n\r\n\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\r\n\t\t\t\t.then( function ( accessor ) {\r\n\r\n\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var gltfAttributeName in attributes ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\r\n\r\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\r\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\r\n\r\n\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\r\n\r\n\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\r\n\r\n\t\t\t\tgeometry.setIndex( accessor );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tpending.push( accessor );\r\n\r\n\t\t}\r\n\r\n\t\tassignExtrasToUserData( geometry, primitiveDef );\r\n\r\n\t\tcomputeBounds( geometry, primitiveDef, parser );\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\treturn primitiveDef.targets !== undefined\r\n\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\r\n\t\t\t\t: geometry;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.BufferGeometry} geometry\r\n\t * @param {Number} drawMode\r\n\t * @return {THREE.BufferGeometry}\r\n\t */\r\n\tfunction toTrianglesDrawMode( geometry, drawMode ) {\r\n\r\n\t\tvar index = geometry.getIndex();\r\n\r\n\t\t// generate index if not present\r\n\r\n\t\tif ( index === null ) {\r\n\r\n\t\t\tvar indices = [];\r\n\r\n\t\t\tvar position = geometry.getAttribute( 'position' );\r\n\r\n\t\t\tif ( position !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\r\n\r\n\t\t\t\t\tindices.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex( indices );\r\n\t\t\t\tindex = geometry.getIndex();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar numberOfTriangles = index.count - 2;\r\n\t\tvar newIndices = [];\r\n\r\n\t\tif ( drawMode === THREE.TriangleFanDrawMode ) {\r\n\r\n\t\t\t// gl.TRIANGLE_FAN\r\n\r\n\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// gl.TRIANGLE_STRIP\r\n\r\n\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\r\n\r\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\r\n\r\n\t\t}\r\n\r\n\t\t// build final geometry\r\n\r\n\t\tvar newGeometry = geometry.clone();\r\n\t\tnewGeometry.setIndex( newIndices );\r\n\r\n\t\treturn newGeometry;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n\t *\r\n\t * Creates BufferGeometries from primitives.\r\n\t *\r\n\t * @param {Array<GLTF.Primitive>} primitives\r\n\t * @return {Promise<Array<THREE.BufferGeometry>>}\r\n\t */\r\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar cache = this.primitiveCache;\r\n\r\n\t\tfunction createDracoPrimitive( primitive ) {\r\n\r\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\r\n\t\t\t\t.decodePrimitive( primitive, parser )\r\n\t\t\t\t.then( function ( geometry ) {\r\n\r\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar primitive = primitives[ i ];\r\n\t\t\tvar cacheKey = createPrimitiveKey( primitive );\r\n\r\n\t\t\t// See if we've already created this geometry\r\n\t\t\tvar cached = cache[ cacheKey ];\r\n\r\n\t\t\tif ( cached ) {\r\n\r\n\t\t\t\t// Use the cached geometry if it exists\r\n\t\t\t\tpending.push( cached.promise );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar geometryPromise;\r\n\r\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\r\n\r\n\t\t\t\t\t// Use DRACO geometry if available\r\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Otherwise create a new geometry\r\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cache this geometry\r\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\r\n\r\n\t\t\t\tpending.push( geometryPromise );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n\t * @param {number} meshIndex\r\n\t * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\r\n\t */\r\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\r\n\t\tvar meshDef = json.meshes[ meshIndex ];\r\n\t\tvar primitives = meshDef.primitives;\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar material = primitives[ i ].material === undefined\r\n\t\t\t\t? createDefaultMaterial( this.cache )\r\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\r\n\r\n\t\t\tpending.push( material );\r\n\r\n\t\t}\r\n\r\n\t\tpending.push( parser.loadGeometries( primitives ) );\r\n\r\n\t\treturn Promise.all( pending ).then( function ( results ) {\r\n\r\n\t\t\tvar materials = results.slice( 0, results.length - 1 );\r\n\t\t\tvar geometries = results[ results.length - 1 ];\r\n\r\n\t\t\tvar meshes = [];\r\n\r\n\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar geometry = geometries[ i ];\r\n\t\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\t\t// 1. create Mesh\r\n\r\n\t\t\t\tvar mesh;\r\n\r\n\t\t\t\tvar material = materials[ i ];\r\n\r\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\r\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\r\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\r\n\t\t\t\t\tprimitive.mode === undefined ) {\r\n\r\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\r\n\t\t\t\t\t\t? new THREE.SkinnedMesh( geometry, material )\r\n\t\t\t\t\t\t: new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\r\n\r\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\r\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\r\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleStripDrawMode );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleFanDrawMode );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\r\n\r\n\t\t\t\t\tmesh = new THREE.LineSegments( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\r\n\r\n\t\t\t\t\tmesh = new THREE.Line( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\r\n\r\n\t\t\t\t\tmesh = new THREE.LineLoop( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\r\n\r\n\t\t\t\t\tmesh = new THREE.Points( geometry, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\r\n\r\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\r\n\r\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\r\n\r\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\r\n\r\n\t\t\t\tparser.assignFinalMaterial( mesh );\r\n\r\n\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meshes.length === 1 ) {\r\n\r\n\t\t\t\treturn meshes[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar group = new THREE.Group();\r\n\r\n\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup.add( meshes[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn group;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n\t * @param {number} cameraIndex\r\n\t * @return {Promise<THREE.Camera>}\r\n\t */\r\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\r\n\r\n\t\tvar camera;\r\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\r\n\t\tvar params = cameraDef[ cameraDef.type ];\r\n\r\n\t\tif ( ! params ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.type === 'perspective' ) {\r\n\r\n\t\t\tcamera = new THREE.PerspectiveCamera( THREE.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\r\n\r\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\r\n\r\n\t\t\tcamera = new THREE.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\r\n\r\n\t\tassignExtrasToUserData( camera, cameraDef );\r\n\r\n\t\treturn Promise.resolve( camera );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n\t * @param {number} skinIndex\r\n\t * @return {Promise<Object>}\r\n\t */\r\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\r\n\r\n\t\tvar skinDef = this.json.skins[ skinIndex ];\r\n\r\n\t\tvar skinEntry = { joints: skinDef.joints };\r\n\r\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\r\n\r\n\t\t\treturn Promise.resolve( skinEntry );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\r\n\r\n\t\t\tskinEntry.inverseBindMatrices = accessor;\r\n\r\n\t\t\treturn skinEntry;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\t * @param {number} animationIndex\r\n\t * @return {Promise<THREE.AnimationClip>}\r\n\t */\r\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\tvar animationDef = json.animations[ animationIndex ];\r\n\r\n\t\tvar pendingNodes = [];\r\n\t\tvar pendingInputAccessors = [];\r\n\t\tvar pendingOutputAccessors = [];\r\n\t\tvar pendingSamplers = [];\r\n\t\tvar pendingTargets = [];\r\n\r\n\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar channel = animationDef.channels[ i ];\r\n\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\r\n\t\t\tvar target = channel.target;\r\n\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\r\n\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\r\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\r\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\r\n\t\t\tpendingSamplers.push( sampler );\r\n\t\t\tpendingTargets.push( target );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\r\n\t\t\tPromise.all( pendingNodes ),\r\n\t\t\tPromise.all( pendingInputAccessors ),\r\n\t\t\tPromise.all( pendingOutputAccessors ),\r\n\t\t\tPromise.all( pendingSamplers ),\r\n\t\t\tPromise.all( pendingTargets )\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar nodes = dependencies[ 0 ];\r\n\t\t\tvar inputAccessors = dependencies[ 1 ];\r\n\t\t\tvar outputAccessors = dependencies[ 2 ];\r\n\t\t\tvar samplers = dependencies[ 3 ];\r\n\t\t\tvar targets = dependencies[ 4 ];\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar node = nodes[ i ];\r\n\t\t\t\tvar inputAccessor = inputAccessors[ i ];\r\n\t\t\t\tvar outputAccessor = outputAccessors[ i ];\r\n\t\t\t\tvar sampler = samplers[ i ];\r\n\t\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\t\tif ( node === undefined ) continue;\r\n\r\n\t\t\t\tnode.updateMatrix();\r\n\t\t\t\tnode.matrixAutoUpdate = true;\r\n\r\n\t\t\t\tvar TypedKeyframeTrack;\r\n\r\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.position:\r\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\r\n\r\n\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;\r\n\r\n\t\t\t\tvar targetNames = [];\r\n\r\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\r\n\r\n\t\t\t\t\t// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\r\n\t\t\t\t\tnode.traverse( function ( object ) {\r\n\r\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetNames.push( targetName );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar outputArray = outputAccessor.array;\r\n\r\n\t\t\t\tif ( outputAccessor.normalized ) {\r\n\r\n\t\t\t\t\tvar scale;\r\n\r\n\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 127;\r\n\r\n\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 255;\r\n\r\n\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 32767;\r\n\r\n\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 65535;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutputArray = scaled;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar track = new TypedKeyframeTrack(\r\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\r\n\t\t\t\t\t\tinputAccessor.array,\r\n\t\t\t\t\t\toutputArray,\r\n\t\t\t\t\t\tinterpolation\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Override interpolation with custom factory method.\r\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\r\n\r\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\r\n\r\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\r\n\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( track );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n\r\n\t\t\treturn new THREE.AnimationClip( name, undefined, tracks );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n\t * @param {number} nodeIndex\r\n\t * @return {Promise<THREE.Object3D>}\r\n\t */\r\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar parser = this;\r\n\r\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\r\n\t\tvar nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\r\n\r\n\t\treturn ( function () {\r\n\r\n\t\t\tvar pending = [];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\r\n\r\n\t\t\t\t\tvar node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\r\n\r\n\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\r\n\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\r\n\r\n\t\t\t\t\t\tnode.traverse( function ( o ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t} ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\r\n\r\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\r\n\r\n\t\t\t\t} ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\r\n\r\n\t\t\t} ).forEach( function ( promise ) {\r\n\r\n\t\t\t\tpending.push( promise );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn Promise.all( pending );\r\n\r\n\t\t}() ).then( function ( objects ) {\r\n\r\n\t\t\tvar node;\r\n\r\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\r\n\t\t\tif ( nodeDef.isBone === true ) {\r\n\r\n\t\t\t\tnode = new THREE.Bone();\r\n\r\n\t\t\t} else if ( objects.length > 1 ) {\r\n\r\n\t\t\t\tnode = new THREE.Group();\r\n\r\n\t\t\t} else if ( objects.length === 1 ) {\r\n\r\n\t\t\t\tnode = objects[ 0 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node !== objects[ 0 ] ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnode.add( objects[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.name ) {\r\n\r\n\t\t\t\tnode.userData.name = nodeDef.name;\r\n\t\t\t\tnode.name = nodeName;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tassignExtrasToUserData( node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.matrix !== undefined ) {\r\n\r\n\t\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\r\n\t\t\t\tnode.applyMatrix4( matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\r\n\r\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n\t * @param {number} sceneIndex\r\n\t * @return {Promise<THREE.Group>}\r\n\t */\r\n\tGLTFParser.prototype.loadScene = function () {\r\n\r\n\t\t// scene node hierachy builder\r\n\r\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\r\n\r\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\r\n\r\n\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\r\n\r\n\t\t\t\tif ( nodeDef.skin === undefined ) return node;\r\n\r\n\t\t\t\t// build skeleton here as well\r\n\r\n\t\t\t\tvar skinEntry;\r\n\r\n\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\r\n\r\n\t\t\t\t\tskinEntry = skin;\r\n\r\n\t\t\t\t\tvar pendingJoints = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn Promise.all( pendingJoints );\r\n\r\n\t\t\t\t} ).then( function ( jointNodes ) {\r\n\r\n\t\t\t\t\tnode.traverse( function ( mesh ) {\r\n\r\n\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\r\n\r\n\t\t\t\t\t\tvar bones = [];\r\n\t\t\t\t\t\tvar boneInverses = [];\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( jointNode ) {\r\n\r\n\t\t\t\t\t\t\t\tbones.push( jointNode );\r\n\r\n\t\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\r\n\r\n\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tboneInverses.push( mat );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} ).then( function ( node ) {\r\n\r\n\t\t\t\t// build node hierachy\r\n\r\n\t\t\t\tparentObject.add( node );\r\n\r\n\t\t\t\tvar pending = [];\r\n\r\n\t\t\t\tif ( nodeDef.children ) {\r\n\r\n\t\t\t\t\tvar children = nodeDef.children;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar child = children[ i ];\r\n\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all( pending );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn function loadScene( sceneIndex ) {\r\n\r\n\t\t\tvar json = this.json;\r\n\t\t\tvar extensions = this.extensions;\r\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\r\n\t\t\tvar parser = this;\r\n\r\n\t\t\t// Loader returns Group, not Scene.\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n\t\t\tvar scene = new THREE.Group();\r\n\t\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\r\n\r\n\t\t\tassignExtrasToUserData( scene, sceneDef );\r\n\r\n\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\r\n\r\n\t\t\tvar nodeIds = sceneDef.nodes || [];\r\n\r\n\t\t\tvar pending = [];\r\n\r\n\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\t\treturn scene;\r\n\r\n\t\t\t} );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\treturn GLTFLoader;\r\n\r\n} )();","R:\\react_app\\myapp\\src\\components\\Test.js",[],"R:\\react_app\\myapp\\src\\components\\Navbar.js",[],"R:\\react_app\\myapp\\src\\components\\Canvasrobo.js",[],"R:\\react_app\\myapp\\src\\components\\Footer.js",[],"R:\\react_app\\myapp\\src\\components\\Aboutme.js",[],"R:\\react_app\\myapp\\src\\components\\Work.js",[],"R:\\react_app\\myapp\\src\\components\\SmoothScroll.js",[],{"ruleId":"229","replacedBy":"230"},{"ruleId":"231","replacedBy":"232"},{"ruleId":"233","severity":2,"message":"234","line":16,"column":1,"nodeType":"235","messageId":"236","endLine":16,"endColumn":6},{"ruleId":"233","severity":2,"message":"234","line":26,"column":20,"nodeType":"235","messageId":"236","endLine":26,"endColumn":25},{"ruleId":"233","severity":2,"message":"234","line":76,"column":31,"nodeType":"235","messageId":"236","endLine":76,"endColumn":36},{"ruleId":"233","severity":2,"message":"234","line":76,"column":55,"nodeType":"235","messageId":"236","endLine":76,"endColumn":60},{"ruleId":"233","severity":2,"message":"234","line":76,"column":80,"nodeType":"235","messageId":"236","endLine":76,"endColumn":85},{"ruleId":"233","severity":2,"message":"234","line":125,"column":20,"nodeType":"235","messageId":"236","endLine":125,"endColumn":25},{"ruleId":"233","severity":2,"message":"234","line":128,"column":18,"nodeType":"235","messageId":"236","endLine":128,"endColumn":23},{"ruleId":"233","severity":2,"message":"234","line":128,"column":72,"nodeType":"235","messageId":"236","endLine":128,"endColumn":77},{"ruleId":"233","severity":2,"message":"234","line":131,"column":26,"nodeType":"235","messageId":"236","endLine":131,"endColumn":31},{"ruleId":"233","severity":2,"message":"234","line":132,"column":28,"nodeType":"235","messageId":"236","endLine":132,"endColumn":33},{"ruleId":"233","severity":2,"message":"234","line":255,"column":22,"nodeType":"235","messageId":"236","endLine":255,"endColumn":27},{"ruleId":"233","severity":2,"message":"234","line":256,"column":27,"nodeType":"235","messageId":"236","endLine":256,"endColumn":32},{"ruleId":"233","severity":2,"message":"234","line":259,"column":22,"nodeType":"235","messageId":"236","endLine":259,"endColumn":27},{"ruleId":"233","severity":2,"message":"234","line":262,"column":24,"nodeType":"235","messageId":"236","endLine":262,"endColumn":29},{"ruleId":"233","severity":2,"message":"234","line":263,"column":22,"nodeType":"235","messageId":"236","endLine":263,"endColumn":27},{"ruleId":"233","severity":2,"message":"234","line":264,"column":24,"nodeType":"235","messageId":"236","endLine":264,"endColumn":29},{"ruleId":"233","severity":2,"message":"234","line":266,"column":21,"nodeType":"235","messageId":"236","endLine":266,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":267,"column":19,"nodeType":"235","messageId":"236","endLine":267,"endColumn":24},{"ruleId":"233","severity":2,"message":"234","line":268,"column":21,"nodeType":"235","messageId":"236","endLine":268,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":270,"column":23,"nodeType":"235","messageId":"236","endLine":270,"endColumn":28},{"ruleId":"233","severity":2,"message":"234","line":271,"column":21,"nodeType":"235","messageId":"236","endLine":271,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":272,"column":23,"nodeType":"235","messageId":"236","endLine":272,"endColumn":28},{"ruleId":"233","severity":2,"message":"234","line":300,"column":15,"nodeType":"235","messageId":"236","endLine":300,"endColumn":20},{"ruleId":"233","severity":2,"message":"234","line":315,"column":15,"nodeType":"235","messageId":"236","endLine":315,"endColumn":20},{"ruleId":"233","severity":2,"message":"234","line":331,"column":20,"nodeType":"235","messageId":"236","endLine":331,"endColumn":25},{"ruleId":"233","severity":2,"message":"234","line":337,"column":33,"nodeType":"235","messageId":"236","endLine":337,"endColumn":38},{"ruleId":"233","severity":2,"message":"234","line":351,"column":40,"nodeType":"235","messageId":"236","endLine":351,"endColumn":45},{"ruleId":"233","severity":2,"message":"234","line":371,"column":32,"nodeType":"235","messageId":"236","endLine":371,"endColumn":37},{"ruleId":"233","severity":2,"message":"234","line":375,"column":39,"nodeType":"235","messageId":"236","endLine":375,"endColumn":44},{"ruleId":"233","severity":2,"message":"234","line":392,"column":32,"nodeType":"235","messageId":"236","endLine":392,"endColumn":37},{"ruleId":"233","severity":2,"message":"234","line":396,"column":39,"nodeType":"235","messageId":"236","endLine":396,"endColumn":44},{"ruleId":"237","severity":1,"message":"238","line":528,"column":3,"nodeType":"239","messageId":"240","endLine":550,"endColumn":4},{"ruleId":"237","severity":1,"message":"238","line":665,"column":3,"nodeType":"239","messageId":"240","endLine":697,"endColumn":4},{"ruleId":"237","severity":1,"message":"238","line":716,"column":3,"nodeType":"239","messageId":"240","endLine":742,"endColumn":4},{"ruleId":"233","severity":2,"message":"234","line":916,"column":1,"nodeType":"235","messageId":"236","endLine":916,"endColumn":6},{"ruleId":"233","severity":2,"message":"234","line":916,"column":48,"nodeType":"235","messageId":"236","endLine":916,"endColumn":53},{"ruleId":"233","severity":2,"message":"234","line":917,"column":1,"nodeType":"235","messageId":"236","endLine":917,"endColumn":6},{"ruleId":"233","severity":2,"message":"234","line":917,"column":45,"nodeType":"235","messageId":"236","endLine":917,"endColumn":50},{"ruleId":"233","severity":2,"message":"234","line":919,"column":26,"nodeType":"235","messageId":"236","endLine":919,"endColumn":31},{"ruleId":"229","replacedBy":"241"},{"ruleId":"231","replacedBy":"242"},{"ruleId":"233","severity":2,"message":"234","line":1,"column":1,"nodeType":"235","messageId":"236","endLine":1,"endColumn":6},{"ruleId":"233","severity":2,"message":"234","line":5,"column":3,"nodeType":"235","messageId":"236","endLine":5,"endColumn":8},{"ruleId":"233","severity":2,"message":"234","line":52,"column":55,"nodeType":"235","messageId":"236","endLine":52,"endColumn":60},{"ruleId":"233","severity":2,"message":"234","line":72,"column":20,"nodeType":"235","messageId":"236","endLine":72,"endColumn":25},{"ruleId":"233","severity":2,"message":"234","line":98,"column":21,"nodeType":"235","messageId":"236","endLine":98,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":191,"column":17,"nodeType":"235","messageId":"236","endLine":191,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":210,"column":16,"nodeType":"235","messageId":"236","endLine":210,"endColumn":21},{"ruleId":"243","severity":1,"message":"244","line":252,"column":15,"nodeType":"235","messageId":"245","endLine":252,"endColumn":16},{"ruleId":"233","severity":2,"message":"234","line":430,"column":19,"nodeType":"235","messageId":"236","endLine":430,"endColumn":24},{"ruleId":"233","severity":2,"message":"234","line":439,"column":21,"nodeType":"235","messageId":"236","endLine":439,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":445,"column":21,"nodeType":"235","messageId":"236","endLine":445,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":450,"column":21,"nodeType":"235","messageId":"236","endLine":450,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":517,"column":10,"nodeType":"235","messageId":"236","endLine":517,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":525,"column":30,"nodeType":"235","messageId":"236","endLine":525,"endColumn":35},{"ruleId":"233","severity":2,"message":"234","line":572,"column":10,"nodeType":"235","messageId":"236","endLine":572,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":623,"column":47,"nodeType":"235","messageId":"236","endLine":623,"endColumn":52},{"ruleId":"233","severity":2,"message":"234","line":653,"column":10,"nodeType":"235","messageId":"236","endLine":653,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":887,"column":11,"nodeType":"235","messageId":"236","endLine":887,"endColumn":16},{"ruleId":"233","severity":2,"message":"234","line":916,"column":20,"nodeType":"235","messageId":"236","endLine":916,"endColumn":25},{"ruleId":"243","severity":1,"message":"246","line":979,"column":8,"nodeType":"235","messageId":"245","endLine":979,"endColumn":26},{"ruleId":"233","severity":2,"message":"234","line":1077,"column":3,"nodeType":"235","messageId":"236","endLine":1077,"endColumn":8},{"ruleId":"233","severity":2,"message":"234","line":1125,"column":27,"nodeType":"235","messageId":"236","endLine":1125,"endColumn":32},{"ruleId":"233","severity":2,"message":"234","line":1239,"column":56,"nodeType":"235","messageId":"236","endLine":1239,"endColumn":61},{"ruleId":"233","severity":2,"message":"234","line":1244,"column":3,"nodeType":"235","messageId":"236","endLine":1244,"endColumn":8},{"ruleId":"233","severity":2,"message":"234","line":1300,"column":32,"nodeType":"235","messageId":"236","endLine":1300,"endColumn":37},{"ruleId":"233","severity":2,"message":"234","line":1320,"column":35,"nodeType":"235","messageId":"236","endLine":1320,"endColumn":40},{"ruleId":"233","severity":2,"message":"234","line":1322,"column":35,"nodeType":"235","messageId":"236","endLine":1322,"endColumn":40},{"ruleId":"233","severity":2,"message":"234","line":1365,"column":30,"nodeType":"235","messageId":"236","endLine":1365,"endColumn":35},{"ruleId":"233","severity":2,"message":"234","line":1413,"column":3,"nodeType":"235","messageId":"236","endLine":1413,"endColumn":8},{"ruleId":"233","severity":2,"message":"234","line":1417,"column":56,"nodeType":"235","messageId":"236","endLine":1417,"endColumn":61},{"ruleId":"233","severity":2,"message":"234","line":1522,"column":9,"nodeType":"235","messageId":"236","endLine":1522,"endColumn":14},{"ruleId":"233","severity":2,"message":"234","line":1523,"column":9,"nodeType":"235","messageId":"236","endLine":1523,"endColumn":14},{"ruleId":"233","severity":2,"message":"234","line":1524,"column":9,"nodeType":"235","messageId":"236","endLine":1524,"endColumn":14},{"ruleId":"233","severity":2,"message":"234","line":1525,"column":9,"nodeType":"235","messageId":"236","endLine":1525,"endColumn":14},{"ruleId":"233","severity":2,"message":"234","line":1526,"column":9,"nodeType":"235","messageId":"236","endLine":1526,"endColumn":14},{"ruleId":"233","severity":2,"message":"234","line":1527,"column":9,"nodeType":"235","messageId":"236","endLine":1527,"endColumn":14},{"ruleId":"233","severity":2,"message":"234","line":1531,"column":10,"nodeType":"235","messageId":"236","endLine":1531,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":1532,"column":10,"nodeType":"235","messageId":"236","endLine":1532,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":1533,"column":10,"nodeType":"235","messageId":"236","endLine":1533,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":1567,"column":11,"nodeType":"235","messageId":"236","endLine":1567,"endColumn":16},{"ruleId":"233","severity":2,"message":"234","line":1568,"column":9,"nodeType":"235","messageId":"236","endLine":1568,"endColumn":14},{"ruleId":"247","severity":1,"message":"248","line":1587,"column":41,"nodeType":"249","messageId":"250","endLine":1587,"endColumn":42,"suggestions":"251"},{"ruleId":"233","severity":2,"message":"234","line":1612,"column":37,"nodeType":"235","messageId":"236","endLine":1612,"endColumn":42},{"ruleId":"233","severity":2,"message":"234","line":1619,"column":11,"nodeType":"235","messageId":"236","endLine":1619,"endColumn":16},{"ruleId":"243","severity":1,"message":"244","line":1696,"column":13,"nodeType":"235","messageId":"245","endLine":1696,"endColumn":14},{"ruleId":"243","severity":1,"message":"252","line":1696,"column":20,"nodeType":"235","messageId":"245","endLine":1696,"endColumn":22},{"ruleId":"243","severity":1,"message":"253","line":1698,"column":8,"nodeType":"235","messageId":"245","endLine":1698,"endColumn":14},{"ruleId":"243","severity":1,"message":"254","line":1712,"column":9,"nodeType":"235","messageId":"245","endLine":1712,"endColumn":24},{"ruleId":"243","severity":1,"message":"244","line":1767,"column":15,"nodeType":"235","messageId":"245","endLine":1767,"endColumn":16},{"ruleId":"243","severity":1,"message":"252","line":1767,"column":22,"nodeType":"235","messageId":"245","endLine":1767,"endColumn":24},{"ruleId":"233","severity":2,"message":"234","line":1850,"column":29,"nodeType":"235","messageId":"236","endLine":1850,"endColumn":34},{"ruleId":"233","severity":2,"message":"234","line":1854,"column":29,"nodeType":"235","messageId":"236","endLine":1854,"endColumn":34},{"ruleId":"233","severity":2,"message":"234","line":1860,"column":25,"nodeType":"235","messageId":"236","endLine":1860,"endColumn":30},{"ruleId":"233","severity":2,"message":"234","line":2292,"column":15,"nodeType":"235","messageId":"236","endLine":2292,"endColumn":20},{"ruleId":"233","severity":2,"message":"234","line":2298,"column":27,"nodeType":"235","messageId":"236","endLine":2298,"endColumn":32},{"ruleId":"233","severity":2,"message":"234","line":2312,"column":27,"nodeType":"235","messageId":"236","endLine":2312,"endColumn":32},{"ruleId":"233","severity":2,"message":"234","line":2331,"column":28,"nodeType":"235","messageId":"236","endLine":2331,"endColumn":33},{"ruleId":"255","severity":2,"message":"256","line":2410,"column":13,"nodeType":"235","messageId":"257","endLine":2410,"endColumn":17},{"ruleId":"255","severity":2,"message":"256","line":2410,"column":25,"nodeType":"235","messageId":"257","endLine":2410,"endColumn":29},{"ruleId":"233","severity":2,"message":"234","line":2456,"column":20,"nodeType":"235","messageId":"236","endLine":2456,"endColumn":25},{"ruleId":"233","severity":2,"message":"234","line":2481,"column":39,"nodeType":"235","messageId":"236","endLine":2481,"endColumn":44},{"ruleId":"233","severity":2,"message":"234","line":2486,"column":62,"nodeType":"235","messageId":"236","endLine":2486,"endColumn":67},{"ruleId":"233","severity":2,"message":"234","line":2487,"column":62,"nodeType":"235","messageId":"236","endLine":2487,"endColumn":67},{"ruleId":"233","severity":2,"message":"234","line":2488,"column":56,"nodeType":"235","messageId":"236","endLine":2488,"endColumn":61},{"ruleId":"233","severity":2,"message":"234","line":2489,"column":56,"nodeType":"235","messageId":"236","endLine":2489,"endColumn":61},{"ruleId":"258","severity":1,"message":"259","line":2517,"column":58,"nodeType":"260","messageId":"261","endLine":2517,"endColumn":60},{"ruleId":"258","severity":1,"message":"262","line":2517,"column":109,"nodeType":"260","messageId":"261","endLine":2517,"endColumn":111},{"ruleId":"233","severity":2,"message":"234","line":2571,"column":26,"nodeType":"235","messageId":"236","endLine":2571,"endColumn":31},{"ruleId":"233","severity":2,"message":"234","line":2572,"column":5,"nodeType":"235","messageId":"236","endLine":2572,"endColumn":10},{"ruleId":"243","severity":1,"message":"263","line":2585,"column":8,"nodeType":"235","messageId":"245","endLine":2585,"endColumn":16},{"ruleId":"233","severity":2,"message":"234","line":2591,"column":24,"nodeType":"235","messageId":"236","endLine":2591,"endColumn":29},{"ruleId":"233","severity":2,"message":"234","line":2592,"column":5,"nodeType":"235","messageId":"236","endLine":2592,"endColumn":10},{"ruleId":"243","severity":1,"message":"263","line":2606,"column":8,"nodeType":"235","messageId":"245","endLine":2606,"endColumn":16},{"ruleId":"233","severity":2,"message":"234","line":2666,"column":10,"nodeType":"235","messageId":"236","endLine":2666,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":2707,"column":31,"nodeType":"235","messageId":"236","endLine":2707,"endColumn":36},{"ruleId":"233","severity":2,"message":"234","line":2751,"column":26,"nodeType":"235","messageId":"236","endLine":2751,"endColumn":31},{"ruleId":"233","severity":2,"message":"234","line":2776,"column":68,"nodeType":"235","messageId":"236","endLine":2776,"endColumn":73},{"ruleId":"233","severity":2,"message":"234","line":2780,"column":37,"nodeType":"235","messageId":"236","endLine":2780,"endColumn":42},{"ruleId":"233","severity":2,"message":"234","line":2790,"column":71,"nodeType":"235","messageId":"236","endLine":2790,"endColumn":76},{"ruleId":"233","severity":2,"message":"234","line":2802,"column":69,"nodeType":"235","messageId":"236","endLine":2802,"endColumn":74},{"ruleId":"233","severity":2,"message":"234","line":2804,"column":34,"nodeType":"235","messageId":"236","endLine":2804,"endColumn":39},{"ruleId":"233","severity":2,"message":"234","line":2808,"column":70,"nodeType":"235","messageId":"236","endLine":2808,"endColumn":75},{"ruleId":"233","severity":2,"message":"234","line":2831,"column":48,"nodeType":"235","messageId":"236","endLine":2831,"endColumn":53},{"ruleId":"233","severity":2,"message":"234","line":2832,"column":64,"nodeType":"235","messageId":"236","endLine":2832,"endColumn":69},{"ruleId":"233","severity":2,"message":"234","line":2849,"column":14,"nodeType":"235","messageId":"236","endLine":2849,"endColumn":19},{"ruleId":"233","severity":2,"message":"234","line":2872,"column":17,"nodeType":"235","messageId":"236","endLine":2872,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":2886,"column":10,"nodeType":"235","messageId":"236","endLine":2886,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":2887,"column":10,"nodeType":"235","messageId":"236","endLine":2887,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":2907,"column":30,"nodeType":"235","messageId":"236","endLine":2907,"endColumn":35},{"ruleId":"233","severity":2,"message":"234","line":2908,"column":21,"nodeType":"235","messageId":"236","endLine":2908,"endColumn":26},{"ruleId":"243","severity":1,"message":"264","line":2916,"column":10,"nodeType":"235","messageId":"245","endLine":2916,"endColumn":18},{"ruleId":"243","severity":1,"message":"265","line":2917,"column":10,"nodeType":"235","messageId":"245","endLine":2917,"endColumn":13},{"ruleId":"243","severity":1,"message":"266","line":2918,"column":10,"nodeType":"235","messageId":"245","endLine":2918,"endColumn":13},{"ruleId":"233","severity":2,"message":"234","line":2952,"column":20,"nodeType":"235","messageId":"236","endLine":2952,"endColumn":25},{"ruleId":"233","severity":2,"message":"234","line":3063,"column":21,"nodeType":"235","messageId":"236","endLine":3063,"endColumn":26},{"ruleId":"243","severity":1,"message":"244","line":3067,"column":14,"nodeType":"235","messageId":"245","endLine":3067,"endColumn":15},{"ruleId":"243","severity":1,"message":"244","line":3079,"column":14,"nodeType":"235","messageId":"245","endLine":3079,"endColumn":15},{"ruleId":"233","severity":2,"message":"234","line":3168,"column":52,"nodeType":"235","messageId":"236","endLine":3168,"endColumn":57},{"ruleId":"233","severity":2,"message":"234","line":3238,"column":13,"nodeType":"235","messageId":"236","endLine":3238,"endColumn":18},{"ruleId":"233","severity":2,"message":"234","line":3239,"column":13,"nodeType":"235","messageId":"236","endLine":3239,"endColumn":18},{"ruleId":"233","severity":2,"message":"234","line":3251,"column":59,"nodeType":"235","messageId":"236","endLine":3251,"endColumn":64},{"ruleId":"233","severity":2,"message":"234","line":3255,"column":59,"nodeType":"235","messageId":"236","endLine":3255,"endColumn":64},{"ruleId":"233","severity":2,"message":"234","line":3261,"column":17,"nodeType":"235","messageId":"236","endLine":3261,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":3265,"column":17,"nodeType":"235","messageId":"236","endLine":3265,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":3269,"column":17,"nodeType":"235","messageId":"236","endLine":3269,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":3273,"column":17,"nodeType":"235","messageId":"236","endLine":3273,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":3305,"column":20,"nodeType":"235","messageId":"236","endLine":3305,"endColumn":25},{"ruleId":"243","severity":1,"message":"244","line":3307,"column":14,"nodeType":"235","messageId":"245","endLine":3307,"endColumn":15},{"ruleId":"243","severity":1,"message":"252","line":3307,"column":21,"nodeType":"235","messageId":"245","endLine":3307,"endColumn":23},{"ruleId":"233","severity":2,"message":"234","line":3339,"column":17,"nodeType":"235","messageId":"236","endLine":3339,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":3339,"column":42,"nodeType":"235","messageId":"236","endLine":3339,"endColumn":47},{"ruleId":"233","severity":2,"message":"234","line":3343,"column":17,"nodeType":"235","messageId":"236","endLine":3343,"endColumn":22},{"ruleId":"233","severity":2,"message":"234","line":3453,"column":28,"nodeType":"235","messageId":"236","endLine":3453,"endColumn":33},{"ruleId":"233","severity":2,"message":"234","line":3458,"column":28,"nodeType":"235","messageId":"236","endLine":3458,"endColumn":33},{"ruleId":"233","severity":2,"message":"234","line":3465,"column":28,"nodeType":"235","messageId":"236","endLine":3465,"endColumn":33},{"ruleId":"233","severity":2,"message":"234","line":3472,"column":104,"nodeType":"235","messageId":"236","endLine":3472,"endColumn":109},{"ruleId":"267","severity":1,"message":"268","line":3479,"column":21,"nodeType":"269","messageId":"270","endLine":3487,"endColumn":7},{"ruleId":"258","severity":1,"message":"262","line":3509,"column":42,"nodeType":"260","messageId":"261","endLine":3509,"endColumn":44},{"ruleId":"243","severity":1,"message":"271","line":3535,"column":15,"nodeType":"235","messageId":"245","endLine":3535,"endColumn":16},{"ruleId":"243","severity":1,"message":"272","line":3535,"column":22,"nodeType":"235","messageId":"245","endLine":3535,"endColumn":24},{"ruleId":"233","severity":2,"message":"234","line":3570,"column":15,"nodeType":"235","messageId":"236","endLine":3570,"endColumn":20},{"ruleId":"233","severity":2,"message":"234","line":3654,"column":16,"nodeType":"235","messageId":"236","endLine":3654,"endColumn":21},{"ruleId":"233","severity":2,"message":"234","line":3658,"column":16,"nodeType":"235","messageId":"236","endLine":3658,"endColumn":21},{"ruleId":"233","severity":2,"message":"234","line":3666,"column":16,"nodeType":"235","messageId":"236","endLine":3666,"endColumn":21},{"ruleId":"233","severity":2,"message":"234","line":3693,"column":22,"nodeType":"235","messageId":"236","endLine":3693,"endColumn":27},{"ruleId":"233","severity":2,"message":"234","line":3779,"column":23,"nodeType":"235","messageId":"236","endLine":3779,"endColumn":28},{"ruleId":"233","severity":2,"message":"234","line":3797,"column":22,"nodeType":"235","messageId":"236","endLine":3797,"endColumn":27},{"ruleId":"233","severity":2,"message":"234","line":3841,"column":20,"nodeType":"235","messageId":"236","endLine":3841,"endColumn":25},"no-native-reassign",["273"],"no-negated-in-lhs",["274"],"no-undef","'THREE' is not defined.","Identifier","undef","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",["273"],["274"],"no-redeclare","'i' is already defined.","redeclared","'threeAttributeName' is already defined.","no-useless-escape","Unnecessary escape character: \\/.","Literal","unnecessaryEscape",["275","276"],"'il' is already defined.","'target' is already defined.","'pendingAccessor' is already defined.","no-restricted-globals","Unexpected use of 'self'.","defaultMessage","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'cacheKey' is already defined.","'accessor' is already defined.","'min' is already defined.","'max' is already defined.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'targetNames'.","FunctionExpression","unsafeRefs","'j' is already defined.","'jl' is already defined.","no-global-assign","no-unsafe-negation",{"messageId":"277","fix":"278","desc":"279"},{"messageId":"280","fix":"281","desc":"282"},"removeEscape",{"range":"283","text":"284"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"285","text":"286"},"Replace the `\\` with `\\\\` to include the actual backslash character.",[40499,40500],"",[40499,40499],"\\"]